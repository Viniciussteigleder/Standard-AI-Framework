#!/usr/bin/env node

/**
 * Standard AI Framework CLI
 * 
 * Commands:
 *   create <project-name>    Create a new project from the framework
 *   init                     Initialize framework in current directory
 *   secrets:setup            Setup centralized secrets
 *   secrets:sync             Sync secrets to current project
 *   add:service <type>       Add a new service (api, agent, web, a2a)
 *   add:integration <name>   Add an integration (google, github, n8n, aws)
 * 
 * Usage:
 *   npx create-ai-project my-app
 *   npx @vinicius/ai-framework create my-app
 */

const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const readline = require('readline');

// =============================================================================
// CONFIGURATION
// =============================================================================

const FRAMEWORK_REPO = 'https://github.com/Viniciussteigleder/Standard-AI-Framework.git';
const SECRETS_DIR = path.join(process.env.HOME || process.env.USERPROFILE, '.ai-framework');
const SECRETS_FILE = path.join(SECRETS_DIR, 'secrets.env');
const CONFIG_FILE = path.join(SECRETS_DIR, 'config.json');

const COLORS = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  red: '\x1b[31m',
  cyan: '\x1b[36m',
};

// =============================================================================
// UTILITIES
// =============================================================================

function log(message, color = 'reset') {
  console.log(`${COLORS[color]}${message}${COLORS.reset}`);
}

function logStep(step, message) {
  console.log(`${COLORS.cyan}[${step}]${COLORS.reset} ${message}`);
}

function logSuccess(message) {
  console.log(`${COLORS.green}‚úì${COLORS.reset} ${message}`);
}

function logError(message) {
  console.log(`${COLORS.red}‚úó${COLORS.reset} ${message}`);
}

function execCommand(command, options = {}) {
  try {
    return execSync(command, { 
      stdio: options.silent ? 'pipe' : 'inherit',
      encoding: 'utf-8',
      ...options 
    });
  } catch (error) {
    if (!options.ignoreError) {
      throw error;
    }
    return null;
  }
}

function ensureSecretsDir() {
  if (!fs.existsSync(SECRETS_DIR)) {
    fs.mkdirSync(SECRETS_DIR, { recursive: true, mode: 0o700 });
  }
}

function readSecrets() {
  if (!fs.existsSync(SECRETS_FILE)) {
    return {};
  }
  
  const content = fs.readFileSync(SECRETS_FILE, 'utf-8');
  const secrets = {};
  
  for (const line of content.split('\n')) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    
    const eqIndex = trimmed.indexOf('=');
    if (eqIndex === -1) continue;
    
    const key = trimmed.slice(0, eqIndex).trim();
    let value = trimmed.slice(eqIndex + 1).trim();
    
    // Remove quotes
    if ((value.startsWith('"') && value.endsWith('"')) || 
        (value.startsWith("'") && value.endsWith("'"))) {
      value = value.slice(1, -1);
    }
    
    secrets[key] = value;
  }
  
  return secrets;
}

function writeSecrets(secrets) {
  ensureSecretsDir();
  
  const lines = ['# AI Framework Centralized Secrets', '# Generated by ai-framework CLI', ''];
  
  const categories = {
    'AI Providers': ['OPENAI_API_KEY', 'OPENAI_ORG_ID', 'ANTHROPIC_API_KEY'],
    'Database': ['DATABASE_URL', 'REDIS_URL'],
    'Auth': ['JWT_SECRET', 'NEXTAUTH_SECRET'],
    'Google': ['GOOGLE_CLIENT_ID', 'GOOGLE_CLIENT_SECRET', 'GOOGLE_SERVICE_ACCOUNT_EMAIL', 'GOOGLE_SERVICE_ACCOUNT_PRIVATE_KEY'],
    'GitHub': ['GITHUB_TOKEN', 'GITHUB_CLIENT_ID', 'GITHUB_CLIENT_SECRET'],
    'AWS': ['AWS_ACCESS_KEY_ID', 'AWS_SECRET_ACCESS_KEY', 'AWS_REGION'],
    'n8n': ['N8N_CLOUD_URL', 'N8N_CLOUD_API_KEY'],
  };
  
  for (const [category, keys] of Object.entries(categories)) {
    const hasAny = keys.some(k => secrets[k]);
    if (hasAny) {
      lines.push(`# ${category}`);
      for (const key of keys) {
        if (secrets[key]) {
          lines.push(`${key}=${secrets[key]}`);
        }
      }
      lines.push('');
    }
  }
  
  // Add any other secrets not in categories
  const categorizedKeys = new Set(Object.values(categories).flat());
  for (const [key, value] of Object.entries(secrets)) {
    if (!categorizedKeys.has(key) && value) {
      lines.push(`${key}=${value}`);
    }
  }
  
  fs.writeFileSync(SECRETS_FILE, lines.join('\n'), { mode: 0o600 });
}

function readConfig() {
  if (!fs.existsSync(CONFIG_FILE)) {
    return { defaultProvider: 'anthropic', projects: [] };
  }
  return JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf-8'));
}

function writeConfig(config) {
  ensureSecretsDir();
  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));
}

async function prompt(question) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  
  return new Promise(resolve => {
    rl.question(question, answer => {
      rl.close();
      resolve(answer.trim());
    });
  });
}

async function promptSecret(question) {
  return prompt(`${question}: `);
}

// =============================================================================
// COMMANDS
// =============================================================================

async function createProject(projectName, options = {}) {
  if (!projectName) {
    logError('Project name is required');
    console.log('Usage: ai-framework create <project-name>');
    process.exit(1);
  }
  
  const targetDir = path.resolve(process.cwd(), projectName);
  
  if (fs.existsSync(targetDir)) {
    logError(`Directory already exists: ${targetDir}`);
    process.exit(1);
  }
  
  log(`\nüöÄ Creating new AI Framework project: ${projectName}\n`, 'bright');
  
  // Step 1: Clone repository
  logStep('1/5', 'Cloning framework repository...');
  execCommand(`git clone --depth 1 ${FRAMEWORK_REPO} "${targetDir}"`);
  
  // Remove .git to start fresh
  fs.rmSync(path.join(targetDir, '.git'), { recursive: true, force: true });
  
  logSuccess('Repository cloned');
  
  // Step 2: Update package.json
  logStep('2/5', 'Configuring project...');
  const packageJsonPath = path.join(targetDir, 'package.json');
  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
  packageJson.name = projectName;
  fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
  logSuccess('Project configured');
  
  // Step 3: Sync secrets
  logStep('3/5', 'Syncing secrets...');
  await syncSecrets(targetDir);
  logSuccess('Secrets synced');
  
  // Step 4: Install dependencies
  logStep('4/5', 'Installing dependencies...');
  process.chdir(targetDir);
  execCommand('pnpm install');
  logSuccess('Dependencies installed');
  
  // Step 5: Initialize git
  logStep('5/5', 'Initializing git repository...');
  execCommand('git init');
  execCommand('git add .');
  execCommand('git commit -m "Initial commit from AI Framework"', { ignoreError: true });
  logSuccess('Git repository initialized');
  
  // Done!
  log(`\n${COLORS.green}‚úì Project created successfully!${COLORS.reset}\n`);
  log('Next steps:', 'bright');
  console.log(`  cd ${projectName}`);
  console.log('  pnpm dev\n');
  
  // Track project
  const config = readConfig();
  config.projects = config.projects || [];
  config.projects.push({
    name: projectName,
    path: targetDir,
    createdAt: new Date().toISOString(),
  });
  writeConfig(config);
}

async function setupSecrets() {
  log('\nüîê AI Framework Secrets Setup\n', 'bright');
  log('Your secrets will be stored securely at:', 'yellow');
  log(`  ${SECRETS_FILE}\n`);
  
  const existing = readSecrets();
  const secrets = { ...existing };
  
  // AI Provider
  log('=== AI Providers ===', 'cyan');
  
  const provider = await prompt('Default AI provider (anthropic/openai) [anthropic]: ');
  const config = readConfig();
  config.defaultProvider = provider || 'anthropic';
  
  if (config.defaultProvider === 'anthropic' || !config.defaultProvider) {
    const key = await promptSecret('Anthropic API Key');
    if (key) secrets.ANTHROPIC_API_KEY = key;
  }
  
  if (config.defaultProvider === 'openai') {
    const key = await promptSecret('OpenAI API Key');
    if (key) secrets.OPENAI_API_KEY = key;
    
    const org = await promptSecret('OpenAI Org ID (optional)');
    if (org) secrets.OPENAI_ORG_ID = org;
  }
  
  // Database
  log('\n=== Database (optional) ===', 'cyan');
  const dbUrl = await promptSecret('Database URL (PostgreSQL)');
  if (dbUrl) secrets.DATABASE_URL = dbUrl;
  
  // Google
  log('\n=== Google Integration (optional) ===', 'cyan');
  const setupGoogle = await prompt('Setup Google integration? (y/n) [n]: ');
  
  if (setupGoogle.toLowerCase() === 'y') {
    const gsaEmail = await promptSecret('Service Account Email');
    if (gsaEmail) secrets.GOOGLE_SERVICE_ACCOUNT_EMAIL = gsaEmail;
    
    const gsaKey = await promptSecret('Service Account Private Key');
    if (gsaKey) secrets.GOOGLE_SERVICE_ACCOUNT_PRIVATE_KEY = gsaKey;
  }
  
  // GitHub
  log('\n=== GitHub Integration (optional) ===', 'cyan');
  const ghToken = await promptSecret('GitHub Personal Access Token');
  if (ghToken) secrets.GITHUB_TOKEN = ghToken;
  
  // AWS
  log('\n=== AWS Integration (optional) ===', 'cyan');
  const setupAws = await prompt('Setup AWS integration? (y/n) [n]: ');
  
  if (setupAws.toLowerCase() === 'y') {
    const awsKey = await promptSecret('AWS Access Key ID');
    if (awsKey) secrets.AWS_ACCESS_KEY_ID = awsKey;
    
    const awsSecret = await promptSecret('AWS Secret Access Key');
    if (awsSecret) secrets.AWS_SECRET_ACCESS_KEY = awsSecret;
    
    const awsRegion = await prompt('AWS Region [eu-central-1]: ');
    secrets.AWS_REGION = awsRegion || 'eu-central-1';
  }
  
  // n8n
  log('\n=== n8n Integration (optional) ===', 'cyan');
  const n8nUrl = await promptSecret('n8n Cloud URL');
  if (n8nUrl) secrets.N8N_CLOUD_URL = n8nUrl;
  
  const n8nKey = await promptSecret('n8n API Key');
  if (n8nKey) secrets.N8N_CLOUD_API_KEY = n8nKey;
  
  // Generate JWT secret if not exists
  if (!secrets.JWT_SECRET) {
    secrets.JWT_SECRET = require('crypto').randomBytes(32).toString('hex');
  }
  if (!secrets.NEXTAUTH_SECRET) {
    secrets.NEXTAUTH_SECRET = require('crypto').randomBytes(32).toString('hex');
  }
  
  // Save
  writeSecrets(secrets);
  writeConfig(config);
  
  log(`\n${COLORS.green}‚úì Secrets saved successfully!${COLORS.reset}`);
  log(`\nSecrets stored at: ${SECRETS_FILE}`, 'yellow');
  log('Run "ai-framework secrets:sync" in any project to sync these secrets.\n');
}

async function syncSecrets(targetDir = process.cwd()) {
  const secrets = readSecrets();
  
  if (Object.keys(secrets).length === 0) {
    log('No secrets configured. Run "ai-framework secrets:setup" first.', 'yellow');
    return;
  }
  
  const envLocalPath = path.join(targetDir, '.env.local');
  const envExamplePath = path.join(targetDir, '.env.example');
  
  // Read existing .env.local or .env.example as base
  let existingEnv = {};
  
  if (fs.existsSync(envLocalPath)) {
    const content = fs.readFileSync(envLocalPath, 'utf-8');
    for (const line of content.split('\n')) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;
      const eqIndex = trimmed.indexOf('=');
      if (eqIndex === -1) continue;
      existingEnv[trimmed.slice(0, eqIndex).trim()] = trimmed.slice(eqIndex + 1).trim();
    }
  } else if (fs.existsSync(envExamplePath)) {
    const content = fs.readFileSync(envExamplePath, 'utf-8');
    for (const line of content.split('\n')) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;
      const eqIndex = trimmed.indexOf('=');
      if (eqIndex === -1) continue;
      existingEnv[trimmed.slice(0, eqIndex).trim()] = trimmed.slice(eqIndex + 1).trim();
    }
  }
  
  // Merge: centralized secrets override local
  const merged = { ...existingEnv, ...secrets };
  
  // Write .env.local
  const lines = [
    '# AI Framework Environment Configuration',
    '# Auto-synced from centralized secrets',
    `# Last synced: ${new Date().toISOString()}`,
    '',
  ];
  
  for (const [key, value] of Object.entries(merged)) {
    if (value && value !== 'your-value-here' && !value.includes('...')) {
      // Quote values with spaces or special chars
      if (value.includes(' ') || value.includes('\n')) {
        lines.push(`${key}="${value.replace(/"/g, '\\"')}"`);
      } else {
        lines.push(`${key}=${value}`);
      }
    }
  }
  
  fs.writeFileSync(envLocalPath, lines.join('\n'));
  logSuccess(`Secrets synced to ${envLocalPath}`);
}

async function addService(type) {
  const TEMPLATES = {
    api: 'service-api',
    agent: 'service-agent',
    web: 'service-web',
    a2a: 'service-a2a',
  };
  
  if (!type || !TEMPLATES[type]) {
    logError(`Unknown service type: ${type}`);
    console.log('Available types: api, agent, web, a2a');
    process.exit(1);
  }
  
  const name = await prompt(`Service name [${type}]: `) || type;
  const templateDir = path.join(__dirname, '..', 'templates', TEMPLATES[type]);
  const targetDir = path.join(process.cwd(), 'apps', name);
  
  if (!fs.existsSync(templateDir)) {
    logError(`Template not found: ${TEMPLATES[type]}`);
    process.exit(1);
  }
  
  if (fs.existsSync(targetDir)) {
    logError(`Service already exists: ${targetDir}`);
    process.exit(1);
  }
  
  // Copy template
  fs.cpSync(templateDir, targetDir, { recursive: true });
  
  // Update package.json
  const packageJsonPath = path.join(targetDir, 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
    packageJson.name = `@framework/${name}`;
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
  }
  
  logSuccess(`Service created: apps/${name}`);
  console.log(`\nNext: pnpm install && pnpm dev:${name}`);
}

async function addIntegration(name) {
  const INTEGRATIONS = ['google', 'github', 'n8n', 'aws'];
  
  if (!name || !INTEGRATIONS.includes(name)) {
    logError(`Unknown integration: ${name}`);
    console.log('Available integrations:', INTEGRATIONS.join(', '));
    process.exit(1);
  }
  
  const integrationDir = path.join(__dirname, '..', 'integrations', name);
  const targetDir = path.join(process.cwd(), 'integrations', name);
  
  if (fs.existsSync(targetDir)) {
    logError(`Integration already exists: ${targetDir}`);
    process.exit(1);
  }
  
  fs.cpSync(integrationDir, targetDir, { recursive: true });
  
  logSuccess(`Integration added: integrations/${name}`);
  console.log(`\nNext: pnpm install`);
}

function showHelp() {
  console.log(`
${COLORS.bright}AI Framework CLI${COLORS.reset}

${COLORS.cyan}Commands:${COLORS.reset}
  create <name>           Create a new project from the framework
  init                    Initialize framework in current directory
  secrets:setup           Configure centralized secrets (one-time setup)
  secrets:sync            Sync centralized secrets to current project
  add:service <type>      Add a service (api, agent, web, a2a)
  add:integration <name>  Add an integration (google, github, n8n, aws)
  help                    Show this help message

${COLORS.cyan}Examples:${COLORS.reset}
  ai-framework create my-app          # Create new project
  ai-framework secrets:setup          # Setup API keys once
  ai-framework secrets:sync           # Sync keys to current project
  ai-framework add:service api        # Add API service

${COLORS.cyan}First-time Setup:${COLORS.reset}
  1. Run: ai-framework secrets:setup
  2. Enter your API keys (Anthropic, OpenAI, etc.)
  3. Create projects: ai-framework create my-project
  4. Your secrets are automatically synced!

${COLORS.yellow}Secrets Location:${COLORS.reset} ~/.ai-framework/secrets.env
`);
}

// =============================================================================
// MAIN
// =============================================================================

async function main() {
  const args = process.argv.slice(2);
  const command = args[0];
  
  switch (command) {
    case 'create':
      await createProject(args[1]);
      break;
    
    case 'init':
      await syncSecrets();
      execCommand('pnpm install');
      break;
    
    case 'secrets:setup':
      await setupSecrets();
      break;
    
    case 'secrets:sync':
      await syncSecrets();
      break;
    
    case 'add:service':
      await addService(args[1]);
      break;
    
    case 'add:integration':
      await addIntegration(args[1]);
      break;
    
    case 'help':
    case '--help':
    case '-h':
      showHelp();
      break;
    
    default:
      if (command) {
        logError(`Unknown command: ${command}`);
      }
      showHelp();
      process.exit(command ? 1 : 0);
  }
}

main().catch(error => {
  logError(error.message);
  process.exit(1);
});
